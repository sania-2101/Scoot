#include <SFML/Graphics.hpp>
#include <vector>
#include <array>
#include <ctime>
#include <cstdlib>
#include <iostream>

const int WIDTH = 10;
const int HEIGHT = 20;
const int BLOCK_SIZE = 30;
const int SCORE_BLOCK_WIDTH = 200;
const int SCORE_BLOCK_HEIGHT = 100;

// Global Grid
std::array<std::array<sf::Color, WIDTH>, HEIGHT> grid = {};

// Tetromino Structure
struct Tetromino {
    std::vector<std::array<int, 2>> shape;
    sf::Color color;

    Tetromino(const std::vector<std::array<int, 2>>& s, const sf::Color& c) : shape(s), color(c) {}
};

// Tetrominoes List
std::vector<Tetromino> tetrominos = {
    Tetromino({ { {0, 0}, {1, 0}, {0, 1}, {1, 1} } }, sf::Color::Yellow),
    Tetromino({ { {0, 0}, {0, 1}, {0, 2}, {0, 3} } }, sf::Color::Cyan),
    Tetromino({ { {0, 0}, {1, 0}, {2, 0}, {2, 1} } }, sf::Color::Blue),
    Tetromino({ { {0, 0}, {1, 0}, {1, 1}, {2, 1} } }, sf::Color::Red),
    Tetromino({ { {0, 1}, {1, 1}, {1, 0}, {2, 0} } }, sf::Color::Green),
    Tetromino({ { {0, 0}, {0, 1}, {1, 1}, {1, 2} } }, sf::Color::White),
    Tetromino({ { {0, 0}, {1, 0}, {2, 0}, {1, 1} } }, sf::Color::Magenta)
};

Tetromino currentTetromino = tetrominos[0];
Tetromino nextTetromino = tetrominos[0];  // Store the upcoming Tetromino
int offsetX = WIDTH / 2 - 1;
int offsetY = 0;

bool gameOver = false;
bool gameStarted = false;

// Score Variable
int score = 0;

// Font and Text
sf::Font font;
sf::Text gameOverText;
sf::Text startText;
sf::Text scoreText;  // Text object for displaying score
sf::Text nextTetrominoText;  // Text for "Next Tetromino"

// Backgrounds
sf::Texture backgroundTexture; // Board Background
sf::Texture startGameTexture;  // Start/Game Over Background
sf::Sprite backgroundSprite;
sf::Sprite startGameSprite;

// Function to Initialize Font, Texts, and Backgrounds
void initializeTextAndBackground() {
    if (!font.loadFromFile("C:/Users/_/source/repos/Project/Project/KnightWarrior-w16n8.otf")) {
        std::cerr << "Error loading font!" << std::endl;
        exit(-1);
    }

    // Start Text
    startText.setFont(font);
    startText.setString("Press Enter to Start");
    startText.setCharacterSize(34);
    startText.setFillColor(sf::Color::Green);
    startText.setStyle(sf::Text::Bold);
    startText.setPosition(WIDTH * BLOCK_SIZE / 2 - startText.getGlobalBounds().width / 2,
        HEIGHT * BLOCK_SIZE / 2 - startText.getGlobalBounds().height / 2);

    // Game Over Text
    gameOverText.setFont(font);
    gameOverText.setString("Game Over! Press Enter to Restart");
    gameOverText.setCharacterSize(18);
    gameOverText.setFillColor(sf::Color::Red);
    gameOverText.setStyle(sf::Text::Bold);
    gameOverText.setPosition(WIDTH * BLOCK_SIZE / 2 - gameOverText.getGlobalBounds().width / 2,
        HEIGHT * BLOCK_SIZE / 2 - gameOverText.getGlobalBounds().height / 2);

    // Score Text
    scoreText.setFont(font);
    scoreText.setCharacterSize(24);
    scoreText.setFillColor(sf::Color::White);
    scoreText.setPosition(WIDTH * BLOCK_SIZE + 10, 30);

    // Next Tetromino Label Text
    nextTetrominoText.setFont(font);
    nextTetrominoText.setString("Next Tetromino:");
    nextTetrominoText.setCharacterSize(20);
    nextTetrominoText.setFillColor(sf::Color::White);
    nextTetrominoText.setPosition(WIDTH * BLOCK_SIZE + 10, 70);  // Below score block

    // Load Board Background
    if (!backgroundTexture.loadFromFile("C:/Users/_/source/repos/Project/Project/board.png")) {
        std::cerr << "Error loading board background image!" << std::endl;
        exit(-1);
    }
    backgroundSprite.setTexture(backgroundTexture);

    // Load Start/Game Over Background
    if (!startGameTexture.loadFromFile("C:/Users/_/source/repos/Project/Project/tetris1stbg.jpeg")) {
        std::cerr << "Error loading start/game over background image!" << std::endl;
        exit(-1);
    }

    // Create a sprite for the background
    startGameSprite.setTexture(startGameTexture);

    // Scale the sprite (adjust the scale factors as needed)
    float scaleFactorX = 2.5f;  // Increase width by 1.5x
    float scaleFactorY = 1.5f;  // Increase height by 1.5x
    startGameSprite.setScale(scaleFactorX, scaleFactorY);
    startGameSprite.setTexture(startGameTexture);
}

// Check Collision
bool checkCollision(const Tetromino& tetromino, int newX, int newY) {
    for (const auto& block : tetromino.shape) {
        int x = block[0] + newX;
        int y = block[1] + newY;

        if (x < 0 || x >= WIDTH || y >= HEIGHT || (y >= 0 && grid[y][x] != sf::Color::Transparent)) {
            return true;
        }
    }
    return false;
}

// Lock Tetromino
void lockTetromino(const Tetromino& tetromino, int posX, int posY) {
    for (const auto& block : tetromino.shape) {
        int x = block[0] + posX;
        int y = block[1] + posY;

        if (y >= 0) {
            grid[y][x] = tetromino.color;
        }
    }
}

// Clear Lines and Update Score
void clearLines() {
    for (int y = HEIGHT - 1; y >= 0; --y) {
        bool full = true;
        for (int x = 0; x < WIDTH; ++x) {
            if (grid[y][x] == sf::Color::Transparent) {
                full = false;
                break;
            }
        }

        if (full) {
            for (int row = y; row > 0; --row) {
                for (int x = 0; x < WIDTH; ++x) {
                    grid[row][x] = grid[row - 1][x];
                }
            }
            for (int x = 0; x < WIDTH; ++x) {
                grid[0][x] = sf::Color::Transparent;
            }

            // Increase score by 100 for each line cleared
            score += 100;

            ++y; // Recheck the same line
        }
    }
}

// Spawn Tetromino
void spawnTetromino() {
    currentTetromino = nextTetromino; // Set the current Tetromino to the next one
    nextTetromino = tetrominos[rand() % tetrominos.size()]; // Pick a new next Tetromino
    offsetX = WIDTH / 2 - 1;
    offsetY = 0;

    if (checkCollision(currentTetromino, offsetX, offsetY)) {
        gameOver = true;
    }
}

// Draw Grid
void drawGrid(sf::RenderWindow& window) {
    for (int y = 0; y < HEIGHT; ++y) {
        for (int x = 0; x < WIDTH; ++x) {
            if (grid[y][x] != sf::Color::Transparent) {
                sf::RectangleShape block(sf::Vector2f(BLOCK_SIZE, BLOCK_SIZE));
                block.setPosition(x * BLOCK_SIZE, y * BLOCK_SIZE);
                block.setFillColor(grid[y][x]);
                block.setOutlineThickness(1);
                block.setOutlineColor(sf::Color::Black);
                window.draw(block);
            }
        }
    }
}

// Draw Tetromino
void drawTetromino(sf::RenderWindow& window) {
    for (const auto& block : currentTetromino.shape) {
        sf::RectangleShape rect(sf::Vector2f(BLOCK_SIZE, BLOCK_SIZE));
        rect.setPosition((block[0] + offsetX) * BLOCK_SIZE, (block[1] + offsetY) * BLOCK_SIZE);
        rect.setFillColor(currentTetromino.color);
        rect.setOutlineThickness(1);
        rect.setOutlineColor(sf::Color::Black);
        window.draw(rect);
    }
}

// Draw the Next Tetromino (Updated in real time)
void drawNextTetromino(sf::RenderWindow& window) {
    // Set position for next Tetromino preview
    int previewX = WIDTH * BLOCK_SIZE + 10;  // Positioning it to the right of the grid
    int previewY = 110;  // Adjust this value to place it below the "Next Tetromino" label

    // Draw the next Tetromino in a smaller grid, without interacting with the main game grid
    for (const auto& block : nextTetromino.shape) {
        sf::RectangleShape rect(sf::Vector2f(BLOCK_SIZE, BLOCK_SIZE));
        rect.setPosition(previewX + block[0] * BLOCK_SIZE, previewY + block[1] * BLOCK_SIZE);
        rect.setFillColor(nextTetromino.color);
        rect.setOutlineThickness(1);
        rect.setOutlineColor(sf::Color::Black);
        window.draw(rect);
    }
}

// Update and Display the Score
void updateScoreText() {
    scoreText.setString("Score: " + std::to_string(score));
}

int main() {
    srand(static_cast<unsigned>(time(nullptr)));

    sf::RenderWindow window(sf::VideoMode(WIDTH * BLOCK_SIZE + SCORE_BLOCK_WIDTH, HEIGHT * BLOCK_SIZE), "Tetris");
    sf::Clock clock;
    float delay = 0.5f;

    initializeTextAndBackground();

    // Reset the score to 0 when the game starts or after a game over
    score = 0;

    spawnTetromino();

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (!gameStarted && event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Enter) {
                gameStarted = true;
                gameOver = false;
                score = 0;  // Reset the score to 0 when starting a new game
            }

            if (gameOver && event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Enter) {
                // Reset the grid and score when restarting after game over
                for (auto& row : grid)
                    row.fill(sf::Color::Transparent);
                gameOver = false;
                score = 0; // Reset the score to 0
                spawnTetromino();
            }
        }

        window.clear();

        if (!gameStarted) {
            window.draw(startGameSprite);
            window.draw(startText);
        }
        else if (gameOver) {
            window.draw(startGameSprite);
            window.draw(gameOverText);
        }
        else {
            window.draw(backgroundSprite);

            // Handle Tetromino movement
            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) {
                if (!checkCollision(currentTetromino, offsetX - 1, offsetY))
                    offsetX -= 1;
            }
            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right)) {
                if (!checkCollision(currentTetromino, offsetX + 1, offsetY))
                    offsetX += 1;
            }
            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down)) {
                if (!checkCollision(currentTetromino, offsetX, offsetY + 1))
                    offsetY += 1;
            }

            if (clock.getElapsedTime().asSeconds() > delay) {
                if (!checkCollision(currentTetromino, offsetX, offsetY + 1)) {
                    offsetY += 1;
                }
                else {
                    lockTetromino(currentTetromino, offsetX, offsetY);
                    clearLines();
                    spawnTetromino();
                }
                clock.restart();
            }

            // Draw grid, current Tetromino, score, and next Tetromino
            drawGrid(window);
            drawTetromino(window);
            updateScoreText();
            window.draw(scoreText);
            window.draw(nextTetrominoText);
            drawNextTetromino(window);
        }

        window.display();
    }

    return 0;
}